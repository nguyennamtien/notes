h1. Java Developer Handbook

h2. Reference System

Java makes uses of Garbage Collection to remove objects from memory that are no longer being used. "_Being used_" normally meaning being _referenced_ by other objects. So this makes life for the developer easier, but it doesn't mean that he doesn't have to think about the lifecycle of an object. The developer could forget to de-reference an object no longer in use (caches and hash maps are a good candidate for such a mistake).

Java supports different types of references.

The _Strong Reference_
<pre>
	StringBuffer buffer = new StringBuffer();
</pre>

This is just your ordinary reference used every day, a new @StringBuffer@ is created and the variable @buffer@ holds a strong reference to it. Remember an object reachable through a chain of strong references is not eligible for garbage collection. This is expected behavior, you don't want the garbage collector to destroy objects you are currently working with.

h3. Weak Reference

A weak reference is a reference that is NOT strong. It can't force an object to remain in memory. You can create a weak reference like so:

bc. WeakReference<MyObject> myObject = new WeakReference<MyObject>(myObject);

At some time myObject might return @null@

h2. finalize()

* every class inherits the @finalize()@ method from @java.lang.Object@
* gets called from GC (Garbage collector), if there are no more references to the object
* @Object.finalize()@ has no method body, but can be overriden
* shoulds be used to close resources, for example

bc. 	protected void finalize() throws Throwable {
	    try {
	        close();        // close open files
	    } finally {
	        super.finalize();
	    }
	}

Every thrown @Exception@ stops the @finalize()@ method, but doesn't stop the GC process

h2. Running junit from ant causes @ClassNotFoundException@

I ran into some problems when trying to calling JUnit tests from an ant script. Some people had the "same poblem":http://blog.anthonychaves.net/java/2006/12/01/solution-for-classnotfoundexception-with-junit-and-ant/comment-page-1#comment-9478 

bq. Apparently Ant expects all the classes to be in Jar files rather than in directories on the file system. A few tweaks to my build.xml file and it looked like this: build.xml Now I’m creating two jar files, one for the application and one for the unit tests. After the unit test jar is created I run them in the JUnit task after setting the classpath with the test jar file. I would have liked to put off creating the application jar file until I knew the JUnit tests passed but that is not an option at this point. I don’t feel strongly enough to make it an option either. I have a 2.4 GHz Pentium 4 computer, I can afford to make a few extra jar files.

The hint is to pack the classes into a jar, and add the jar to the classpath and not the directory whee the classes reside.