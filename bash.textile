h1. Shell 

This is not a complete guide, but a collection of hints that makes the life with your shell easier. As my main system is a Mac, some hints might only work on OS X.

h2. Shortcuts

* @ctrl + a@ Jump to beginning of line
* @ctrl + e@ Jump to end of line
* @ctrl + r@ Start search (just start typing), pressing multiple times toggles through occurrences in history
* @ctrl + l@ Clear terminal

h2. Redirecting/Appending Standard Output

* @>@ redirects _StdOut_, for example to a file @command > path@ or to @/dev/null@ (discards all data)
* @>>@ appends the output to the path @command >> path@

Similar for _StdErr_, but use @2@ prefix like so @2>@ or respectively. @2>>@.

h2. Using the history

Why use your brain to remember all the commands you have to use again and again. Just rely on your terminal and the history file it keeps.

Bash supports @Ctrl + r@ to search the history. Per default the size history (and therefore the number of entries) is rather limited. You can do that by setting some variables in your @.profile@ or (@.bash_profile@)

WARNING: OSX prefers the @.profile@ to @.bash_profile@. If both exists *only*  @.profile@ will be read (see ".profile not read":#profile-not-read)

bc. #.bash_profile or .profile
export HISTFILESIZE=1000000000      # sets history size to something really big
export HISTSIZE=1000000             # sets history size to something really big
 
You can also set to ignore duplicates of commands (@ls@, @ps -ef@ are such candidates)

bc. #.bash_profile or .profile
export HISTCONTROL=ignoreboth

Other useful settings are

bc. # append to the same history file when using multiple terminals
shopt -qs histappend

bc. # when typing part of a filename and press Tab to autocomplete, Bash does a case-insensitive search.
shopt -qs nocaseglob

bc. # minor errors in the spelling of a directory component in a cd command will be corrected
shopt -qs cdspell

h2. .inputrc

Next to @.profile@ there is also @.inputrc@. This is the configuration file for GNU Readline (a library that allows to edit commands as they are typed in) 

*An exemplary scenario* is when you have to login to multiple servers using @ssh ...@ commands. Instead of toggling through all the occurrences in the history you can just start typing away @ssh @.

With the following snippet in the @.inputrc@ file you can then just use your arrow keys to scroll through all the occurrences starting with the prefix you have typed in so far. This is especially useful when multiple logins share the same user but have different hosts.

bc. 	# By default up/down are bound to previous-history
	# and next-history respectively. The following does the
	# same but gives the extra functionality where if you
	# type any text (or more accurately, if there is any text
	# between the start of the line and the cursor),
	# the subset of the history starting with that text
	# is searched (like 4dos for e.g.).
	# Note to get rid of a line just Ctrl-C
	"\e[A": history-search-backward
	"\e[B": history-search-forward

It doesn't stop there. If you like to move around in your command more quickly you might find use in the following snippet, which allows to jump over words in your command using @Strg@ and the left or right arrow key.

bc. 	# move around word for word with Strg + arrow keys
	"\e[5C": forward-word
	"\e[5D": backward-word
	"\e\e[C": forward-word
	"\e\e[D": backward-word

This one is very helpful when you just type away and realize later that the first character of is upper case instead of lower case (the default directories in the home directory of OSX all start with upper case letters).

bc. 	# case insensitivity for tab-completion
	set completion-ignore-case On

h2. Finding stuff

* *Sorts the current directory after size* in human readable form @ls -lSrh@ 
* *Biggest directory* @du -kx | egrep -v "\./.+/" | sort -n@
* *Finds a file and shows space in use* @locate somefile | xargs ls -lsh@

h3. Grep

@find . -name "*" -exec grep -il "searchphrase" {} \;@

bc. -i ignores case
-l shows filename

h3. Search in man pages

Just type @/@ and then the word you search for. 

h3. Useful search queries

* Files *greater than 1GB* @find /path -size +1024000k -print@
* Files *less than 7 days old* @find /path -mtime -7 -print@
* Files *longer than 7 days old* @find /path -mtime +7 -print@
* *Executable files* @find /path -perm -100 -print@
* Files *with @-r--r--r--@ permissions* @find /path -perm 444 -print@
* *Directories with write permissions* @find /path -type -perm 777 -print@
* Files *with specific extension* @find /path -name '*.ext' -print@

h2. File attributes

h3. ls -l "weirdness" +/@ symbol in @ls -l@

Sometimes when using @ls -l@ there is a @+@ or a @@@ symbol

bc. 	$ ls -la
	-rwx------+ 1 testuser Admin     25600 Jul 12 02:04 file.ext
	-rwx------@ 1 testuser Admin     25600 Jul 12 02:04 file.ext

The @+@ indicates the use of ACL (Access Control Lists). Consult "ACL":#acl for more infos.

The @@@ indicates further file attributes. Consult "Apple File Attributes":#apple-file-attributes for more infos.

h3(#acl). Access Control lists

To view them just use @ls -le@.

This is a rather huge topic. Run @man chmod@ and search for acl for a complete description.

To delete an acl entry you have to run @chmod -a@ with the exact defintion of the acl. For example:

bc. 	$ ls -le
	-rw-rw----+ 1 Joe  staff      14336  1 Dez 12:23 file.ext
	0: group:everyone deny delete
	$ chmod -a "group:everyone deny delete" file.ext

h3(#apple-file-attributes). Apple File Attributes

Apple adds an extra file attribute when files have been downloaded from the internet. It can be seen when using @ls -ls@ indicated by the @@@ symbol. By calling @ls -@@ you can see that an attribute @com.apple.quarantine@ has been added. To remove that call @sudo xattr -d com.apple.quarantine path@

h2. Helpful commands

h3. Various

*Resolve to canonical path*. Useful if you used symbolic links to switch into a director

bc. pwd -P

*Create symbolic link* in @/destination/path@ to @/existing/path@ 

bc. ln -s /existing/path /destination/path
 
*Change to previous working directory* 

bc. cd -@ 

Run the *last command as root* 

bc. sudo !!

Runs *previous command but replacing first instance of foo with bar* 

bc. ^foo^bar

Runs *previous command but replacing all instances of foo with bar* 

bc. !!:gs/foo/bar

*Copy ssh key* to server 

bc. cat ~/.ssh/id_rsa.pub | ssh account@remoteserver.com "cat - >> .ssh/authorized_keys"

*Spider a website* 

bc. httrack "http://www.all.net/" -O "/tmp/www.all.net" "+*.all.net/*" -v

*Query wikipedia via dns* 

bc. dig +short txt <keyword>.wp.dg.cx

*Stopwatch* (ctrl-d to stop) 

bc. time read

*SSH connection through host in the middle* 

bc. ssh -t reachable_host ssh unreachable_host

*Sharing file through port 80*, access with @http://ip-address/@ 

bc. nc -q 1 -w 5 -v -l -p 80 < file.ext

*Disk usage in readable form* 

bc. du -sh [file ...]

*Rename all files in directory to lowercase* 

bc. for x in *; do mv "$x" "`echo $x | tr [A-Z] [a-z]`"; done

*Replace "space" char with "dot"* char in current directory file names 

bc. ls -1 | while read a; do mv "$a" `echo $a | sed -e 's/\ /\./g'`; done

*Batch rename files, replacing _foo_ with _bar_*

bc. for file in *.*; do mv $file `echo $file | sed 's/bar/foo/g'` ; done

*Create missing directory when moving files* 

bc. mkdir -p ./some/path/; mv yourfile.txt $_

*Download a file with "authorization" cookie* 

bc. wget --server-response --continue --load-cookies cookies.txt http://host.com/file.ext

*Recursively remove @.svn@ directories* 

bc. find . -type d -name '.svn' -print0 | xargs -0 rm -rdf

*Get public IP address*

bc. curl -s checkip.dyndns.org|sed -e 's/.*Current IP Address: //' -e 's/<.*$//'

*Get geographic locatio from ip*
bc. curl -s "http://www.geody.com/geoip.php?ip=10.0.0.1" | sed '/^IP:/!d;s/<[^>][^>]*>//g' ;
curl -s "http://geoip.pidgets.com?ip=10.0.0.1&format=json"

h3. rsync

bc. rsync -rv
rsync -arvz

- r (recursive) := copies directories and sub directories
- v (verbose) := prints on the screen what is being copied, increase verbosity by adding more @v@, like @-vv@ or @-vvv@
- a (archive) := symbolic links, devices, attributes, permissions, ownerships, etc. are preserved
- z (compressed) := data will be compressed over the network

To copy the contents of @path@ to @/volume/path/@

bc. $ rsync -r /path/ /volume/path/

To copy the folder @path@ and its contents to @/volume/path@ (it will create the folder: path):

bc. $ rsync -r /path /volume/path

Without the final slash, rsync will copy the directory in its entirety. With the trailing slash, it will copy the contents of the directory but won't recreate the directory

Exclude files by adding patterns, for example you can exclude hidden files ba adding

bc. --exclude=".*/"

rsync even has an built in option to exclude @cvs@ or @svn@ files, just add

bc. --cvs-exclude

h2. FAQ/Problems

h3(#profile-not-read). Bash doesn't update the PATH; changes to .profile aren't registered

Adding something like @EXPORT PATH=/usr/bin:$PATH@ doesn't update the @$PATH@ environment variable. The reason is that Bash tries to find local profile files in the following order:

bc. # ~/.bash_profile
# ~/.bash_login
# ~/.profile

@~/.profile@ is the last file in the list. So if OS X finds a file it stops processing. If an installer puts a @.bash_login@ in your home directory your @.profile@ wouldn't be read.

h3. Reload .profile

bc. $ . ~/.profile