h1. Shell 

This is not a complete guide, but a collection of hints that makes the life with your shell easier. As my main system is OS X, some tipps might only work on this system.

h2. Shortcuts

* @ctrl + a@ Jump to beginning of line
* @ctrl + e@ Jump to end of line
* @ctrl + r@ Start search (just start typing), pressing multiple times toggles through occurences in history
* @ctrl + l@ Clear terminal

h2. Umlenken der Ausgabe

* @>@ redirects _StdOut_, to a file or to @/dev/null@
* @>>@ to append

Similiar for _StdErr_, but use @2@ prefix like so @2>@ or respectively. @2>>@.

h2. Nutzen der History

Warum Shellbefehle merken müssen oder immer wieder neu eingeben, wenn man sie doch einfach aus der History wieder herausholen kann?

Die Bash unterstützt @Ctrl + r@ um in der History zu suchen. Leider ist die History zu klein um sie wirklich ausnutzen zu können. Also einfach mal den Speicherplatz vergrößern. Dies kann in der @.profile@ bzw. in der @.bash_profile@ passieren. Das zwei Namen existieren ist historisch begründet.

Hinweis: Gerade OSX macht einem hier gerne einen Stich durch die Rechnung und präferiert @.profile@ gegenüber der @.bash_profile@. Da etwaige Installationen (etwa aus MacPorts) mal die eine oder andere anlegen, kann es zu Verwirrungen kommen.

<pre>        
 #.bash_profile or .profile
export HISTFILESIZE=1000000000      # sets history size to something really big
export HISTSIZE=1000000             # sets history size to something really big
</pre>
 
Da ich häufig auch in einem Ordner bleibe und Befehle wiederhole (ls, ps, ..., svn update), weise ich die History an wiederholte Befehle zu ignorieren
 
<pre>        
 #.bash_profile or .profile
export HISTCONTROL=ignoreboth
</pre>

@shopt -qs histappend@  append to the same history file when using multiple terminals
@shopt -qs cdspell@ minor errors in the spelling of a directory component in a cd command will be corrected
@shopt -qs nocaseglob@ when typing part of a filename and press Tab to autocomplete, Bash does a case-insensitive search.

h2. .inputrc

Neben de Profile gibt es auch noch eine @.inputrc@. Das ist eine Konfigurationsdatei für GNU Readline. Hiermit kann man schöne Dinge machen, falls einem @Ctrl + R@ manchmal zu umständlich ist.

Man muss sich in viele verschiedene Server einloggen, so dass die History voll mit @ssh ...@ Befehlen ist. Man fängt also an und tippt @ssh @. Mit Hilfe des Schnipsels unten in der @.inputrc@ kann man nun wie ewohnt mit Pfeil hoch und runter in der History arbeiten, aber die es werden nur die Einträge herausgesucht, die mit @ssh@ beginnen.  
   
<pre>
	# By default up/down are bound to previous-history
	# and next-history respectively. The following does the
	# same but gives the extra functionality where if you
	# type any text (or more accurately, if there is any text
	# between the start of the line and the cursor),
	# the subset of the history starting with that text
	# is searched (like 4dos for e.g.).
	# Note to get rid of a line just Ctrl-C
	"\e[A": history-search-backward
	"\e[B": history-search-forward
</pre>

Hilfreich wenn man in Wörtern springen möchte

<pre>
	# move arround word for word with Strg + arrow keys
	"\e[5C": forward-word
	"\e[5D": backward-word
	"\e\e[C": forward-word
	"\e\e[D": backward-word
</pre>

<pre>
	# case insensitivity for tab-completion
	set completion-ignore-case On
</pre> 

h2. Finding stuff

* *Sorts the current directory after size* in human readable form @ls -lSrh@ 
* *Biggest directory* @du -kx | egrep -v "\./.+/" | sort -n@
* *Finds a file and shows space in use* @locate somefile | xargs ls -lsh@

h3. Grep

@find . -name "*" -exec grep -il "searchphrase" {} \;@

<pre>
-i ignores case
-l shows filename
</pre>

h2. Helpful commands

h3. Various

* *Create symbolic link* in @/destination/path@ to @/existing/path@ @ln -s /existing/path /destination/path@ 
* *Change to previous working directory* @cd -@ 
* Run the *last command as root* @sudo !!@ 
* Runs *previous command but replacing first instance of foo with bar* @^foo^bar@ 
* Runs *previous command but replacing all instances of foo with bar* @!!:gs/foo/bar@
* *Copy ssh key* to server <code>cat ~/.ssh/id_rsa.pub | ssh account@remoteserver.com "cat - >> .ssh/authorized_keys"</code>
* *Spider a website* @httrack "http://www.all.net/" -O "/tmp/www.all.net" "+*.all.net/*" -v@
* *Query wikipedia via dns* @dig +short txt <keyword>.wp.dg.cx@
* *Stopwatch* (ctrl-d to stop) @time read@
* *SSH connection through host in the middle* @ssh -t reachable_host ssh unreachable_host@
* *Sharing file through port 80*, access with @http://ip-address/@ @nc -q 1 -w 5 -v -l -p 80 < file.ext@
* *Disk usage in readable form* @du -sh [file ...]@ 
* *Rename all files in directory to lowercase* @for x in *; do mv "$x" "`echo $x | tr [A-Z] [a-z]`"; done@

h2. FAQ/Problems

h3. Bash doesn't update the PATH; changes to .profile aren' registered

Adding something like @EXPORT PATH=/usr/bin:$PATH@ doesn't update the @$PATH@ environment variable. The reason is that Bash tries to find local profile files in the following order:

<pre>
# ~/.bash_profile
# ~/.bash_login
# ~/.profile
</pre>

@~/.profile@ is the last file in the list. So if OS X finds a file it stops processing. If an installer puts a @.bash_login@ in your home directory your @.profile@ would'nt be read.
