h1. Shell 

This is not a complete guide, but a collection of hints that makes the life with your shell easier. As my main system is OS X, some tipps might only work on this system.

h2. Shortcuts

* @ctrl + a@ Jump to beginning of line
* @ctrl + e@ Jump to end of line
* @ctrl + r@ Start search (just start typing), pressing multiple times toggles through occurences in history
* @ctrl + l@ Clear terminal

h2. Redirecting/Appending Standard Output

* @>@ redirects _StdOut_, for example to a file @command > path@ or to @/dev/null@ (discards all data)
* @>>@ appends the output to the path @command >> path@

Similiar for _StdErr_, but use @2@ prefix like so @2>@ or respectively. @2>>@.

h2. Using the history

Why use your brain to remember all the commands you have to use again and again. Just rely on your terminal and the history file it keeps.

Bash supports @Ctrl + r@ to search the history. Per default the size history (and therefore the number of entries) is rather limited. You can do that by setting some variables in your @.profile@ or (@.bash_profile@)

WARNING: OSX preferes the @.profile@ to @.bash_profile@. If both exists *only*  @.profile@ will be read (see ".profile not read":#profile-not-read)

<pre>        
 #.bash_profile or .profile
export HISTFILESIZE=1000000000      # sets history size to something really big
export HISTSIZE=1000000             # sets history size to something really big
</pre>
 
You can also set to ignore duplicates of commands (@ls@, @ps -ef@ are such candidates)
 
<pre>        
 #.bash_profile or .profile
export HISTCONTROL=ignoreboth
</pre>

Other useful settings are

<pre>
# append to the same history file when using multiple terminals
shopt -qs histappend
</pre>

<pre>
# when typing part of a filename and press Tab to autocomplete, Bash does a case-insensitive search.
shopt -qs nocaseglob
</pre>

<pre>
# minor errors in the spelling of a directory component in a cd command will be corrected
shopt -qs cdspell
</pre>

h2. .inputrc

Next to @.profile@ there is also @.inputrc@. This is the configuration file for GNU Readline (a library that allows to edit commands as they are typed in) 

*An exemplary scenario* is when you have to login to multiple servers using @ssh ...@ commands. Instead of toggling through all the occurences in the history you can just start typing away @ssh @.

With the following snippet in the @.inputrc@ file you can then just use your arrow keys to scroll through all the occurences starting with the prefix you have typed in so far. This is especially useful when multiple logins share the same user but have different hosts.
   
<pre>
	# By default up/down are bound to previous-history
	# and next-history respectively. The following does the
	# same but gives the extra functionality where if you
	# type any text (or more accurately, if there is any text
	# between the start of the line and the cursor),
	# the subset of the history starting with that text
	# is searched (like 4dos for e.g.).
	# Note to get rid of a line just Ctrl-C
	"\e[A": history-search-backward
	"\e[B": history-search-forward
</pre>

It doesn't stop there. If you like to move arround in your command more quickly you might find use in the following snippet, which allows to jump over words in your command using @Strg@ and the left or right arrow key.

<pre>
	# move arround word for word with Strg + arrow keys
	"\e[5C": forward-word
	"\e[5D": backward-word
	"\e\e[C": forward-word
	"\e\e[D": backward-word
</pre>

This one is very helpful when you just type away and realise later that the first character of is upper case instead of lower case (the default directories in the home directory of OSX all start with upper case letters).

<pre>
	# case insensitivity for tab-completion
	set completion-ignore-case On
</pre> 

h2. Finding stuff

* *Sorts the current directory after size* in human readable form @ls -lSrh@ 
* *Biggest directory* @du -kx | egrep -v "\./.+/" | sort -n@
* *Finds a file and shows space in use* @locate somefile | xargs ls -lsh@

h3. Grep

@find . -name "*" -exec grep -il "searchphrase" {} \;@

<pre>
-i ignores case
-l shows filename
</pre>

h2. ls -l weirdness

Sometimes when using @ls -l@ there is a @+@ or a <code>@</code> symbol

<pre>
	$ ls -la
	-rwx------+ 1 testuser Admin     25600 Jul 12 02:04 file.ext
	-rwx------@ 1 testuser Admin     25600 Jul 12 02:04 file.ext
</pre>

The @+@ indicates the user of ACL (Access Control Lists)
The <code>@</code> indicates further file attributes

h2. File attributes

h3. Apple

Apple adds an extra file attribute when files have been downloaded from the internet. It can be seen when using <code>ls -ls</code> indicated by the <code>@</code> symbol. By calling <code>ls -@</code> you can see that an attribute @com.apple.quarantine@ has been added. To remove that call @sudo xattr -d com.apple.quarantine path@

h2. Helpful commands

h3. Various

* *Create symbolic link* in @/destination/path@ to @/existing/path@ @ln -s /existing/path /destination/path@ 
* *Change to previous working directory* @cd -@ 
* Run the *last command as root* @sudo !!@ 
* Runs *previous command but replacing first instance of foo with bar* @^foo^bar@ 
* Runs *previous command but replacing all instances of foo with bar* @!!:gs/foo/bar@
* *Copy ssh key* to server <code>cat ~/.ssh/id_rsa.pub | ssh account@remoteserver.com "cat - >> .ssh/authorized_keys"</code>
* *Spider a website* @httrack "http://www.all.net/" -O "/tmp/www.all.net" "+*.all.net/*" -v@
* *Query wikipedia via dns* @dig +short txt <keyword>.wp.dg.cx@
* *Stopwatch* (ctrl-d to stop) @time read@
* *SSH connection through host in the middle* @ssh -t reachable_host ssh unreachable_host@
* *Sharing file through port 80*, access with @http://ip-address/@ @nc -q 1 -w 5 -v -l -p 80 < file.ext@
* *Disk usage in readable form* @du -sh [file ...]@ 
* *Rename all files in directory to lowercase* @for x in *; do mv "$x" "`echo $x | tr [A-Z] [a-z]`"; done@
* *Replace "space" char with "dot"* char in current directory file names @ls -1 | while read a; do mv "$a" `echo $a | sed -e 's/\ /\./g'`; done@
* *Batch rename files, replacing foo with bar* *@for file in *.*; do mv $file `echo $file | sed 's/foo/bar/g'` ; done@

h2. FAQ/Problems

h3(#profile-not-read). Bash doesn't update the PATH; changes to .profile aren' registered

Adding something like @EXPORT PATH=/usr/bin:$PATH@ doesn't update the @$PATH@ environment variable. The reason is that Bash tries to find local profile files in the following order:

<pre>
# ~/.bash_profile
# ~/.bash_login
# ~/.profile
</pre>

@~/.profile@ is the last file in the list. So if OS X finds a file it stops processing. If an installer puts a @.bash_login@ in your home directory your @.profile@ would'nt be read.